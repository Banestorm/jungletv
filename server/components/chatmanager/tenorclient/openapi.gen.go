// Package tenorclient provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.9.1 DO NOT EDIT.
package tenorclient

import (
	"context"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
)

// Defines values for ArRange.
const (
	All ArRange = "all"

	Standard ArRange = "standard"

	Wide ArRange = "wide"
)

// Defines values for Contentfilter.
const (
	False Contentfilter = "false"

	High Contentfilter = "high"

	Low Contentfilter = "low"

	Medium Contentfilter = "medium"
)

// Defines values for MediaFilter.
const (
	Basic MediaFilter = "basic"

	Minimal MediaFilter = "minimal"
)

// Defines values for Type.
const (
	Emoji Type = "emoji"

	Featured Type = "featured"

	Trending Type = "trending"
)

// AutocompleteResult defines model for AutocompleteResult.
type AutocompleteResult struct {
	// An array of suggested search terms.
	Results []string `json:"results"`
}

// CategoriesResult defines model for CategoriesResult.
type CategoriesResult struct {
	// an array of CategoryObjects where the “name” field has been translated to the passed in locale language.
	Tags []CategoryObject `json:"tags"`
}

// CategoryObject defines model for CategoryObject.
type CategoryObject struct {
	// a url to the media source for the category's example GIF
	Image string `json:"image"`

	// Category name to overlay over the image. The name will be translated to match the locale of the corresponding request
	Name string `json:"name"`

	// the search url to request if the user selects the category
	Path string `json:"path"`

	// the English search term that corresponds to the category
	Searchterm string `json:"searchterm"`
}

// GifObject defines model for GifObject.
type GifObject struct {
	ContentDescription string `json:"content_description"`

	// a unix timestamp representing when this post was created.
	Created float32 `json:"created"`

	// true if this post contains audio (only video formats support audio, the gif image file format can not contain audio information).
	Hasaudio bool `json:"hasaudio"`

	// Tenor result identifier
	Id string `json:"id"`

	// An array of dictionaries with GIF_FORMAT as the key and MEDIA_OBJECT as the value
	Media []Media `json:"media"`

	// an array of tags for the post
	Tags  []string `json:"tags"`
	Title string   `json:"title"`
}

// Media defines model for Media.
type Media struct {
	Gif       *MediaObject `json:"gif,omitempty"`
	Loopedmp4 *MediaObject `json:"loopedmp4,omitempty"`
	Mediumgif *MediaObject `json:"mediumgif,omitempty"`
	Mp4       *MediaObject `json:"mp4,omitempty"`
	Nanogif   *MediaObject `json:"nanogif,omitempty"`
	Nanomp4   *MediaObject `json:"nanomp4,omitempty"`
	Nanowebm  *MediaObject `json:"nanowebm,omitempty"`
	Tinygif   *MediaObject `json:"tinygif,omitempty"`
	Tinymp4   *MediaObject `json:"tinymp4,omitempty"`
	Tinywebm  *MediaObject `json:"tinywebm,omitempty"`
	Webm      *MediaObject `json:"webm,omitempty"`
}

// MediaObject defines model for MediaObject.
type MediaObject struct {
	// width and height in pixels
	Dims []int `json:"dims"`

	// a url to a preview image of the media source
	Preview string `json:"preview"`

	// size of file in bytes
	Size int `json:"size"`

	// a url to the media source
	Url string `json:"url"`
}

// a position identifier to use with the next API query to retrieve the next set of results, or null if there are no further results.
type Next string

// RegisterResult defines model for RegisterResult.
type RegisterResult struct {
	// set to "ok" if share registration was successful
	Status string `json:"status"`
}

// SearchResult defines model for SearchResult.
type SearchResult struct {
	// a position identifier to use with the next API query to retrieve the next set of results, or null if there are no further results.
	Next Next `json:"next"`

	// an array of GifObjects containing the most relevant GIFs for the requested search term - Sorted by relevancy Rank
	Results []GifObject `json:"results"`
}

// AnonId defines model for anon_id.
type AnonId string

// ArRange defines model for ar_range.
type ArRange string

// Contentfilter defines model for contentfilter.
type Contentfilter string

// Id defines model for id.
type Id string

// Ids defines model for ids.
type Ids string

// Key defines model for key.
type Key string

// Limit defines model for limit.
type Limit int

// Locale defines model for locale.
type Locale string

// MediaFilter defines model for media_filter.
type MediaFilter string

// Pos defines model for pos.
type Pos string

// Q defines model for q.
type Q string

// Type defines model for type.
type Type string

// AutocompleteParams defines parameters for Autocomplete.
type AutocompleteParams struct {
	// a search string
	Q Q `json:"q"`

	// client key for privileged API access
	Key Key `json:"key"`

	// specify default language to interpret search string; xx is ISO 639-1 language code, _YY (optional) is 2-letter ISO 3166-1 country code
	Locale *Locale `json:"locale,omitempty"`

	// fetch up to a specified number of results (max: 50).
	Limit *Limit `json:"limit,omitempty"`

	// specify the anonymous_id tied to the given user
	AnonId *AnonId `json:"anon_id,omitempty"`
}

// CategoriesParams defines parameters for Categories.
type CategoriesParams struct {
	// client key for privileged API access
	Key Key `json:"key"`

	// specify default language to interpret search string; xx is ISO 639-1 language code, _YY (optional) is 2-letter ISO 3166-1 country code
	Locale *Locale `json:"locale,omitempty"`

	// (values: featured | emoji | trending ) determines the type of categories returned
	Type *CategoriesParamsType `json:"type,omitempty"`

	// (values: off | low | medium | high) specify the content safety filter level
	Contentfilter *CategoriesParamsContentfilter `json:"contentfilter,omitempty"`

	// specify the anonymous_id tied to the given user
	AnonId *AnonId `json:"anon_id,omitempty"`
}

// CategoriesParamsType defines parameters for Categories.
type CategoriesParamsType string

// CategoriesParamsContentfilter defines parameters for Categories.
type CategoriesParamsContentfilter string

// GifsParams defines parameters for Gifs.
type GifsParams struct {
	// a comma separated list of GIF IDs (max: 50)
	Ids *Ids `json:"ids,omitempty"`

	// client key for privileged API access
	Key Key `json:"key"`

	// (values: basic | minimal) Reduce the Number of GIF formats returned in the GIF_OBJECT list.
	//
	// minimal - tinygif, gif, and mp4.
	//
	// basic - nanomp4, tinygif, tinymp4, gif, mp4, and nanogif
	MediaFilter *GifsParamsMediaFilter `json:"media_filter,omitempty"`

	// fetch up to a specified number of results (max: 50).
	Limit *Limit `json:"limit,omitempty"`

	// get results starting at position "value". Use a non-zero "next" value returned by API results to get the next set of results. pos is not an index and may be an integer, float, or string
	Pos *Pos `json:"pos,omitempty"`

	// specify the anonymous_id tied to the given user
	AnonId *AnonId `json:"anon_id,omitempty"`
}

// GifsParamsMediaFilter defines parameters for Gifs.
type GifsParamsMediaFilter string

// RandomParams defines parameters for Random.
type RandomParams struct {
	// a search string
	Q Q `json:"q"`

	// client key for privileged API access
	Key Key `json:"key"`

	// specify default language to interpret search string; xx is ISO 639-1 language code, _YY (optional) is 2-letter ISO 3166-1 country code
	Locale *Locale `json:"locale,omitempty"`

	// (values: off | low | medium | high) specify the content safety filter level
	Contentfilter *RandomParamsContentfilter `json:"contentfilter,omitempty"`

	// (values: basic | minimal) Reduce the Number of GIF formats returned in the GIF_OBJECT list.
	//
	// minimal - tinygif, gif, and mp4.
	//
	// basic - nanomp4, tinygif, tinymp4, gif, mp4, and nanogif
	MediaFilter *RandomParamsMediaFilter `json:"media_filter,omitempty"`

	// (values: all | wide | standard ) Filter the response GIF_OBJECT list to only include GIFs with aspect ratios that fit with in the selected range.
	//
	// all - no constraints
	//
	// wide - 0.42 <= aspect ratio <= 2.36
	//
	// standard - .56 <= aspect ratio <= 1.78
	ArRange *RandomParamsArRange `json:"ar_range,omitempty"`

	// fetch up to a specified number of results (max: 50).
	Limit *Limit `json:"limit,omitempty"`

	// get results starting at position "value". Use a non-zero "next" value returned by API results to get the next set of results. pos is not an index and may be an integer, float, or string
	Pos *Pos `json:"pos,omitempty"`

	// specify the anonymous_id tied to the given user
	AnonId *AnonId `json:"anon_id,omitempty"`
}

// RandomParamsContentfilter defines parameters for Random.
type RandomParamsContentfilter string

// RandomParamsMediaFilter defines parameters for Random.
type RandomParamsMediaFilter string

// RandomParamsArRange defines parameters for Random.
type RandomParamsArRange string

// RegisterParams defines parameters for Register.
type RegisterParams struct {
	// client key for privileged API access
	Key Key `json:"key"`

	// the id of a GifObject
	Id *Id `json:"id,omitempty"`

	// specify default language to interpret search string; xx is ISO 639-1 language code, _YY (optional) is 2-letter ISO 3166-1 country code
	Locale *Locale `json:"locale,omitempty"`

	// a search string
	Q Q `json:"q"`

	// specify the anonymous_id tied to the given user
	AnonId *AnonId `json:"anon_id,omitempty"`
}

// SearchParams defines parameters for Search.
type SearchParams struct {
	// a search string
	Q Q `json:"q"`

	// client key for privileged API access
	Key Key `json:"key"`

	// specify default language to interpret search string; xx is ISO 639-1 language code, _YY (optional) is 2-letter ISO 3166-1 country code
	Locale *Locale `json:"locale,omitempty"`

	// (values: off | low | medium | high) specify the content safety filter level
	Contentfilter *SearchParamsContentfilter `json:"contentfilter,omitempty"`

	// (values: basic | minimal) Reduce the Number of GIF formats returned in the GIF_OBJECT list.
	//
	// minimal - tinygif, gif, and mp4.
	//
	// basic - nanomp4, tinygif, tinymp4, gif, mp4, and nanogif
	MediaFilter *SearchParamsMediaFilter `json:"media_filter,omitempty"`

	// (values: all | wide | standard ) Filter the response GIF_OBJECT list to only include GIFs with aspect ratios that fit with in the selected range.
	//
	// all - no constraints
	//
	// wide - 0.42 <= aspect ratio <= 2.36
	//
	// standard - .56 <= aspect ratio <= 1.78
	ArRange *SearchParamsArRange `json:"ar_range,omitempty"`

	// fetch up to a specified number of results (max: 50).
	Limit *Limit `json:"limit,omitempty"`

	// get results starting at position "value". Use a non-zero "next" value returned by API results to get the next set of results. pos is not an index and may be an integer, float, or string
	Pos *Pos `json:"pos,omitempty"`

	// specify the anonymous_id tied to the given user
	AnonId *AnonId `json:"anon_id,omitempty"`
}

// SearchParamsContentfilter defines parameters for Search.
type SearchParamsContentfilter string

// SearchParamsMediaFilter defines parameters for Search.
type SearchParamsMediaFilter string

// SearchParamsArRange defines parameters for Search.
type SearchParamsArRange string

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// Autocomplete request
	Autocomplete(ctx context.Context, params *AutocompleteParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Categories request
	Categories(ctx context.Context, params *CategoriesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Gifs request
	Gifs(ctx context.Context, params *GifsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Random request
	Random(ctx context.Context, params *RandomParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Register request
	Register(ctx context.Context, params *RegisterParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Search request
	Search(ctx context.Context, params *SearchParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) Autocomplete(ctx context.Context, params *AutocompleteParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAutocompleteRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Categories(ctx context.Context, params *CategoriesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCategoriesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Gifs(ctx context.Context, params *GifsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGifsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Random(ctx context.Context, params *RandomParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRandomRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Register(ctx context.Context, params *RegisterParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRegisterRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Search(ctx context.Context, params *SearchParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewAutocompleteRequest generates requests for Autocomplete
func NewAutocompleteRequest(server string, params *AutocompleteParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/autocomplete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, params.Q); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "key", runtime.ParamLocationQuery, params.Key); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Locale != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "locale", runtime.ParamLocationQuery, *params.Locale); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.AnonId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "anon_id", runtime.ParamLocationQuery, *params.AnonId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCategoriesRequest generates requests for Categories
func NewCategoriesRequest(server string, params *CategoriesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/categories")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "key", runtime.ParamLocationQuery, params.Key); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Locale != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "locale", runtime.ParamLocationQuery, *params.Locale); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Type != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Contentfilter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "contentfilter", runtime.ParamLocationQuery, *params.Contentfilter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.AnonId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "anon_id", runtime.ParamLocationQuery, *params.AnonId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGifsRequest generates requests for Gifs
func NewGifsRequest(server string, params *GifsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/gifs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Ids != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "key", runtime.ParamLocationQuery, params.Key); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.MediaFilter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "media_filter", runtime.ParamLocationQuery, *params.MediaFilter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Pos != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pos", runtime.ParamLocationQuery, *params.Pos); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.AnonId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "anon_id", runtime.ParamLocationQuery, *params.AnonId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRandomRequest generates requests for Random
func NewRandomRequest(server string, params *RandomParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/random")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, params.Q); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "key", runtime.ParamLocationQuery, params.Key); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Locale != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "locale", runtime.ParamLocationQuery, *params.Locale); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Contentfilter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "contentfilter", runtime.ParamLocationQuery, *params.Contentfilter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.MediaFilter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "media_filter", runtime.ParamLocationQuery, *params.MediaFilter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ArRange != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ar_range", runtime.ParamLocationQuery, *params.ArRange); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Pos != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pos", runtime.ParamLocationQuery, *params.Pos); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.AnonId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "anon_id", runtime.ParamLocationQuery, *params.AnonId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRegisterRequest generates requests for Register
func NewRegisterRequest(server string, params *RegisterParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/register")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "key", runtime.ParamLocationQuery, params.Key); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Id != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Locale != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "locale", runtime.ParamLocationQuery, *params.Locale); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, params.Q); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.AnonId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "anon_id", runtime.ParamLocationQuery, *params.AnonId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchRequest generates requests for Search
func NewSearchRequest(server string, params *SearchParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, params.Q); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "key", runtime.ParamLocationQuery, params.Key); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Locale != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "locale", runtime.ParamLocationQuery, *params.Locale); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Contentfilter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "contentfilter", runtime.ParamLocationQuery, *params.Contentfilter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.MediaFilter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "media_filter", runtime.ParamLocationQuery, *params.MediaFilter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ArRange != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ar_range", runtime.ParamLocationQuery, *params.ArRange); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Pos != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pos", runtime.ParamLocationQuery, *params.Pos); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.AnonId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "anon_id", runtime.ParamLocationQuery, *params.AnonId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// Autocomplete request
	AutocompleteWithResponse(ctx context.Context, params *AutocompleteParams, reqEditors ...RequestEditorFn) (*AutocompleteResponse, error)

	// Categories request
	CategoriesWithResponse(ctx context.Context, params *CategoriesParams, reqEditors ...RequestEditorFn) (*CategoriesResponse, error)

	// Gifs request
	GifsWithResponse(ctx context.Context, params *GifsParams, reqEditors ...RequestEditorFn) (*GifsResponse, error)

	// Random request
	RandomWithResponse(ctx context.Context, params *RandomParams, reqEditors ...RequestEditorFn) (*RandomResponse, error)

	// Register request
	RegisterWithResponse(ctx context.Context, params *RegisterParams, reqEditors ...RequestEditorFn) (*RegisterResponse, error)

	// Search request
	SearchWithResponse(ctx context.Context, params *SearchParams, reqEditors ...RequestEditorFn) (*SearchResponse, error)
}

type AutocompleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AutocompleteResult
}

// Status returns HTTPResponse.Status
func (r AutocompleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AutocompleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CategoriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CategoriesResult
}

// Status returns HTTPResponse.Status
func (r CategoriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CategoriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GifsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SearchResult
}

// Status returns HTTPResponse.Status
func (r GifsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GifsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RandomResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SearchResult
}

// Status returns HTTPResponse.Status
func (r RandomResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RandomResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RegisterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RegisterResult
}

// Status returns HTTPResponse.Status
func (r RegisterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RegisterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SearchResult
}

// Status returns HTTPResponse.Status
func (r SearchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// AutocompleteWithResponse request returning *AutocompleteResponse
func (c *ClientWithResponses) AutocompleteWithResponse(ctx context.Context, params *AutocompleteParams, reqEditors ...RequestEditorFn) (*AutocompleteResponse, error) {
	rsp, err := c.Autocomplete(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAutocompleteResponse(rsp)
}

// CategoriesWithResponse request returning *CategoriesResponse
func (c *ClientWithResponses) CategoriesWithResponse(ctx context.Context, params *CategoriesParams, reqEditors ...RequestEditorFn) (*CategoriesResponse, error) {
	rsp, err := c.Categories(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCategoriesResponse(rsp)
}

// GifsWithResponse request returning *GifsResponse
func (c *ClientWithResponses) GifsWithResponse(ctx context.Context, params *GifsParams, reqEditors ...RequestEditorFn) (*GifsResponse, error) {
	rsp, err := c.Gifs(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGifsResponse(rsp)
}

// RandomWithResponse request returning *RandomResponse
func (c *ClientWithResponses) RandomWithResponse(ctx context.Context, params *RandomParams, reqEditors ...RequestEditorFn) (*RandomResponse, error) {
	rsp, err := c.Random(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRandomResponse(rsp)
}

// RegisterWithResponse request returning *RegisterResponse
func (c *ClientWithResponses) RegisterWithResponse(ctx context.Context, params *RegisterParams, reqEditors ...RequestEditorFn) (*RegisterResponse, error) {
	rsp, err := c.Register(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRegisterResponse(rsp)
}

// SearchWithResponse request returning *SearchResponse
func (c *ClientWithResponses) SearchWithResponse(ctx context.Context, params *SearchParams, reqEditors ...RequestEditorFn) (*SearchResponse, error) {
	rsp, err := c.Search(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchResponse(rsp)
}

// ParseAutocompleteResponse parses an HTTP response from a AutocompleteWithResponse call
func ParseAutocompleteResponse(rsp *http.Response) (*AutocompleteResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AutocompleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AutocompleteResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCategoriesResponse parses an HTTP response from a CategoriesWithResponse call
func ParseCategoriesResponse(rsp *http.Response) (*CategoriesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CategoriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CategoriesResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGifsResponse parses an HTTP response from a GifsWithResponse call
func ParseGifsResponse(rsp *http.Response) (*GifsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GifsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SearchResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRandomResponse parses an HTTP response from a RandomWithResponse call
func ParseRandomResponse(rsp *http.Response) (*RandomResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RandomResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SearchResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRegisterResponse parses an HTTP response from a RegisterWithResponse call
func ParseRegisterResponse(rsp *http.Response) (*RegisterResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RegisterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RegisterResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSearchResponse parses an HTTP response from a SearchWithResponse call
func ParseSearchResponse(rsp *http.Response) (*SearchResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SearchResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}
